package main

import (
	"context"
	"dagger/terragrunt/internal/dagger"
	"fmt"
	"strings"
)

// ActionResult represents the result of a Continuous Integration (CI) action.
// It contains information about the unit that was executed, the output of the action,
// and any error that may have occurred during execution.
type ActionResult struct {
	WorkDir string // WorkDir indicates the specific unit of work that was executed.
	Output  string // Output contains the result or output generated by the action.
	Err     error  // Err holds any error encountered during the execution of the action.
}

// ActionCmd represents a command to be executed in the context of a Terragrunt action.
// It encapsulates the command string and its associated arguments, allowing for flexible
// execution of various Terragrunt commands with the specified parameters.
//
// Fields:
//   - Command: A string that specifies the command to be executed (e.g., "apply", "destroy").
//   - Args: A slice of strings that contains additional arguments to be passed to the command.
//     These arguments can modify the behavior of the command or provide necessary parameters
//     for its execution.
type ActionCmd struct {
	Command string   // The command to be executed.
	Args    []string // Additional arguments for the command.
}

// TerragruntActionBuilder is a struct that helps configure and execute a single
// Terragrunt action. It encapsulates all necessary parameters and settings required
// to perform a Terragrunt command, such as "hclfmt", "validate", or "init".
type TerragruntActionBuilder struct {
	parent             *Terragrunt       // Reference to the main Terragrunt module that this action belongs to.
	command            string            // The specific Terragrunt command to be executed (e.g., "hclfmt", "validate", "init").
	binary             string            // The binary to be used for this action (e.g., "terragrunt", "terraform").
	args               []string          // A slice of additional arguments to be passed to the command.
	unitEnv            string            // The environment in which the Terragrunt unit operates (e.g., "global").
	unitLayer          string            // The layer of the Terragrunt unit (e.g., "dni").
	unitName           string            // The name of the Terragrunt unit (e.g., "dni_generator").
	tfModule           string            // The name of the Terraform module (e.g., "dni_generator").
	src                *dagger.Directory // The source directory for this action, defaults to the parent module's source directory.
	awsAccessKeyID     *dagger.Secret    // The AWS Access Key ID to be used for this action, if applicable.
	awsSecretKey       *dagger.Secret    // The AWS Secret Key to be used for this action, if applicable.
	awsRegion          string            // The AWS region to be used for this action.
	awsRoleArn         string            // The AWS role ARN to be assumed for this action, if applicable.
	awsOidcToken       *dagger.Secret    // The AWS OIDC token to be used for this action, if applicable.
	awsRoleSessionName string            // The AWS role session name to be used for this action, if applicable.
	envVars            []string          // A slice of additional environment variables for this action.
	secrets            []*dagger.Secret  // A slice of additional secrets required for this action (name -> secret mapping).
	noCache            bool              // A flag indicating whether to apply a cache buster for this action.
	loadDotEnvFile     bool              // A flag indicating whether to load a .env file for this action.
	autoApprove        bool              // A flag indicating whether to automatically approve Terraform commands like apply/destroy.
	tfToken            *dagger.Secret    // The Terraform registry token to be used for authentication, if applicable.
	ghToken            *dagger.Secret    // The GitHub token for accessing GitHub resources, if applicable.
	glToken            *dagger.Secret    // The GitLab token for accessing GitLab resources, if applicable.
	gitSshSocket       *dagger.Socket    // The Git SSH socket for supporting private Git repositories.
}

// NewAction creates and returns a new instance of the TerragruntActionBuilder struct,
// which is responsible for configuring and executing a specific Terragrunt command.
// The provided command parameter specifies the Terragrunt command to be executed,
// such as "hclfmt", "validate", or "init".
//
// This method initializes the builder with default values for the unit environment,
// layer, and name, as well as the AWS region and source directory. The default values
// are defined by constants such as defaultRefArchEnv, defaulttRefArchLayer, and
// defaulttRefArchUnit. The AWS region is set to "eu-central-1" by default.
//
// The source directory for the action defaults to the source directory of the parent
// Terragrunt instance, which can be overridden by using the WithSource method on the
// returned TerragruntActionBuilder instance.
//
// This method is typically called on a Terragrunt instance to prepare for executing
// a specific Terragrunt command, allowing for further configuration through method
// chaining on the returned builder instance.
//
// Parameters:
//   - command: A string representing the specific Terragrunt command to be executed.
//
// Returns:
//   - A pointer to a newly created TerragruntActionBuilder instance, initialized
//     with the specified command and default values for other parameters.
func (m *Terragrunt) NewAction(command string) *TerragruntActionBuilder {
	return &TerragruntActionBuilder{
		parent:    m,
		command:   command,
		unitEnv:   defaultRefArchEnv,
		unitLayer: defaulttRefArchLayer,
		unitName:  defaulttRefArchUnit,
		binary:    "terragrunt",
		awsRegion: "eu-central-1",
		envVars:   []string{},
		secrets:   []*dagger.Secret{},
	}
}

// ForTgUnit configures the Terragrunt action with the specified unit environment, layer, and name.
// This method allows the user to set the context in which the Terragrunt command will be executed.
// If any of the parameters are empty strings, default values will be used instead.
//
// Parameters:
//   - env: A string representing the environment in which the command will run (e.g., "global").
//   - layer: A string representing the layer in which the command will run (e.g., "dni").
//   - unit: A string representing the name of the unit in which the command will run (e.g., "dni_generator").
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method chaining.
func (b *TerragruntActionBuilder) ForTgUnit(env, layer, unit string) *TerragruntActionBuilder {
	if env == "" {
		env = defaultRefArchEnv
	}

	if layer == "" {
		layer = defaulttRefArchLayer
	}

	if unit == "" {
		unit = defaulttRefArchUnit
	}

	b.unitEnv = env
	b.unitLayer = layer
	b.unitName = unit

	return b
}

// ForTgModule configures the Terragrunt action with the specified Terraform module name.
// This method allows the user to set the context in which the Terragrunt command will be executed.
// If the module name is empty, the action will not be configured for a specific module.
//
// Parameters:
//   - module: A string representing the name of the Terraform module (e.g., "dni_generator").
func (b *TerragruntActionBuilder) ForTgModule(module string) *TerragruntActionBuilder {
	if module == "" {
		return b
	}

	b.tfModule = module
	return b
}

// WithArgs appends additional command-line arguments to the Terragrunt command being built.
// This method allows users to specify any number of additional arguments that will be included
// when the command is executed. The arguments are added to the existing list of arguments,
// enabling flexible command construction.
//
// Parameters:
//   - args: A variadic parameter that accepts one or more strings representing the
//     additional arguments to be added to the command. These arguments will be appended
//     to the internal slice of arguments maintained by the TerragruntActionBuilder.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method chaining
//     to further configure the action.
func (b *TerragruntActionBuilder) WithArgs(args ...string) *TerragruntActionBuilder {
	b.args = append(b.args, args...)
	return b
}

// WithSource sets the source directory for the Terragrunt action being built.
// This method allows the user to specify a source directory that will be used
// during the execution of the Terragrunt command. If the provided source directory
// is not nil, it will be assigned to the action builder; otherwise, the existing
// source directory will remain unchanged.
//
// Parameters:
//   - src: A pointer to a dagger.Directory representing the source directory
//     to be used for the action. If src is nil, the source directory will not
//     be updated.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithSource(src *dagger.Directory) *TerragruntActionBuilder {
	if src != nil {
		b.src = src
	}

	return b
}

func (b *TerragruntActionBuilder) WithTerraformInsteadOfTerragrunt() *TerragruntActionBuilder {
	b.binary = "terraform"
	return b
}

// ConnectToAWSWithCredentials configures the AWS credentials for the Terragrunt action being built.
// This method allows users to specify the AWS access key ID, secret access key,
// and the AWS region that will be used during the execution of the Terragrunt command.
//
// Parameters:
//   - awsAccessKeyID: A pointer to a dagger.Secret representing the AWS access key ID
//     to be used for the action. If this parameter is nil, the access key ID will not
//     be set.
//   - awsSecretAccessKey: A pointer to a dagger.Secret representing the AWS secret
//     access key to be used for the action. If this parameter is nil, the secret access
//     key will not be set.
//   - awsRegion: A string representing the AWS region to be used for the action. If
//     the provided region is empty or not set, the default AWS region will be used.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method
//     chaining to further configure the action.
func (b *TerragruntActionBuilder) ConnectToAWSWithCredentials(awsAccessKeyID, awsSecretAccessKey *dagger.Secret, awsRegion string) *TerragruntActionBuilder {
	awsRegion = getDefaultAWSRegionIfNotSet(awsRegion)

	b.awsAccessKeyID = awsAccessKeyID
	b.awsSecretKey = awsSecretAccessKey
	b.awsRegion = awsRegion

	return b
}

// ConnectToAWSWithOIDC configures the builder to use AWS OIDC authentication.
// It stores the necessary details (Role ARN, OIDC Token Secret, Region, Session Name)
// which will be used by Execute to set up the container environment.
// Parameters:
//   - roleArn: The ARN of the IAM role to assume.
//   - oidcToken: The Dagger Secret containing the OIDC JWT token from GitLab.
//   - region: The AWS region.
//   - sessionName: An optional name for the assumed role session.
func (b *TerragruntActionBuilder) ConnectToAWSWithOIDC(
	// roleARN is the ARN of the IAM role to assume.
	roleARN string,
	// oidcToken is the Dagger Secret containing the OIDC JWT token from GitLab.
	oidcToken *dagger.Secret,
	// awsRegion is the AWS region.
	// +optional
	awsRegion string,
	// sessionName is an optional name for the assumed role session.
	// +optional
	sessionName string) *TerragruntActionBuilder {
	awsRegion = getDefaultAWSRegionIfNotSet(awsRegion)
	b.awsRoleArn = roleARN
	b.awsOidcToken = oidcToken
	b.awsRegion = awsRegion
	if sessionName != "" {
		b.awsRoleSessionName = sessionName
	}

	// Clear static creds if OIDC is configured, as they are mutually exclusive
	b.awsAccessKeyID = nil
	b.awsSecretKey = nil

	return b
}

// WithEnv adds an environment variable to the Terragrunt action being built.
// This method allows users to specify a key-value pair that will be set as an
// environment variable during the execution of the action. If either the key or
// the value is an empty string, the environment variable will not be added.
//
// Parameters:
//   - key: A string representing the name of the environment variable to be set.
//   - value: A string representing the value of the environment variable to be set.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithEnv(key, value string) *TerragruntActionBuilder {
	if key != "" && value != "" {
		b.envVars = append(b.envVars, fmt.Sprintf("%s=%s", key, value))
	}

	return b
}

// WithEnvVars sets the environment variables for the Terragrunt action being built.
// This method allows users to specify a slice of strings representing environment
// variables that will be set during the execution of the Terragrunt action. The
// provided slice will replace any existing environment variables previously set.
//
// Parameters:
//   - envVars: A slice of strings where each string represents an environment variable
//     in the format "KEY=VALUE". This will be used to configure the environment for
//     the action. If the slice is empty, the existing environment variables will be
//     cleared.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method
//     chaining to further configure the action.
func (b *TerragruntActionBuilder) WithEnvVars(envVars []string) *TerragruntActionBuilder {
	b.envVars = envVars
	return b
}

// WithSecret adds a secret to the action.
//
// Parameters:
//   - key: The key of the secret.
//   - secret: The secret to add to the action.
//
// WithSecret adds a secret to the Terragrunt action being built. This method allows users
// to specify a secret that will be included in the action's execution context. If the provided
// secret is nil, the method will simply return the current instance of TerragruntActionBuilder
// without making any modifications.
//
// Parameters:
//   - ctx: A context.Context that carries deadlines, cancellation signals, and other request-scoped
//     values across API boundaries and between processes.
//   - name: A string representing the name under which the secret will be stored in the action.
//   - secret: A pointer to a dagger.Secret that contains the secret value to be added. If this
//     parameter is nil, the method will not add any secret and will return the builder instance.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method chaining
//     to further configure the action.
func (b *TerragruntActionBuilder) WithSecret(ctx context.Context, name string, secret *dagger.Secret) *TerragruntActionBuilder {
	if secret == nil {
		return b
	}

	secretPlainTxtValue, _ := secret.Plaintext(ctx)
	newSecret := dag.SetSecret(name, secretPlainTxtValue)
	b.secrets = append(b.secrets, newSecret)

	return b
}

// WithNoCache sets the cache buster for the Terragrunt action being built.
// This method is used to indicate that the action should not use any cached
// results from previous executions. By setting the noCache flag to true,
// the action will always execute fresh, ensuring that the latest state
// is used during the execution of the Terragrunt command.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing
//     for method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithNoCache() *TerragruntActionBuilder {
	b.noCache = true
	return b
}

// WithSourceCodeMounted sets the source code directory for the Terragrunt action being built.
// This method allows users to specify a source code directory that will be used
// during the execution of the Terragrunt command. If the provided source code
// directory is not nil, it will be assigned to the action builder; otherwise,
// the existing source code directory will remain unchanged.
func (b *TerragruntActionBuilder) WithSourceCodeMounted(dir *dagger.Directory) *TerragruntActionBuilder {
	b.src = dir
	return b
}

// WithLoadDotEnvFile enables loading of the .env file for the Terragrunt action being built.
// This method sets a flag indicating that the action should read environment variables
// from a .env file, which can be useful for managing configuration settings and secrets
// in a centralized manner. By enabling this feature, the action will have access to
// the environment variables defined in the .env file during its execution.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method
//     chaining to further configure the action.
func (b *TerragruntActionBuilder) WithLoadDotEnvFile() *TerragruntActionBuilder {
	b.loadDotEnvFile = true
	return b
}

// WithAutoApprove enables automatic approval for the Terragrunt action being built.
// This method sets a flag indicating that the action should proceed without requiring
// manual approval for any changes that may be applied. This is particularly useful
// in automated environments where user interaction is not feasible, such as CI/CD
// pipelines. By enabling this feature, the action will execute with the assumption
// that all changes are acceptable, streamlining the deployment process.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method
//     chaining to further configure the action.
func (b *TerragruntActionBuilder) WithAutoApprove() *TerragruntActionBuilder {
	b.autoApprove = true
	return b
}

// WithTerraformToken sets the Terraform token for the Terragrunt action being built.
// This method allows the user to specify a token that will be used for authentication
// with Terraform services. The token is expected to be a secret, which helps in
// keeping sensitive information secure. By setting this token, the action can
// interact with Terraform APIs that require authentication, enabling operations
// such as applying configurations or managing state.
//
// Parameters:
//   - token: A pointer to a dagger.Secret that contains the Terraform token.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithTerraformToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.tfToken = token
	return b
}

// WithGitHubToken sets the GitHub token for the Terragrunt action being built.
// This method allows the user to specify a token that will be used for authentication
// with GitHub services. The token is expected to be a secret, which helps in
// keeping sensitive information secure. By setting this token, the action can
// interact with GitHub APIs that require authentication, enabling operations
// such as accessing repositories or managing pull requests.
//
// Parameters:
//   - token: A pointer to a dagger.Secret that contains the GitHub token.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithGitHubToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.ghToken = token
	return b
}

// WithGitLabToken sets the GitLab token for the Terragrunt action being built.
// This method allows the user to specify a token that will be used for authentication
// with GitLab services. The token is expected to be a secret, which helps in
// keeping sensitive information secure. By setting this token, the action can
// interact with GitLab APIs that require authentication, enabling operations
// such as accessing repositories, managing issues, or triggering CI/CD pipelines.
//
// Parameters:
//   - token: A pointer to a dagger.Secret that contains the GitLab token.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithGitLabToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.glToken = token
	return b
}

// WithGitSSHSocket sets the Git SSH socket for the Terragrunt action being built.
// This method allows the user to specify a socket that will be used for SSH connections
// to Git repositories. By setting this socket, the action can interact with Git services
// that require SSH authentication, enabling operations such as cloning repositories or
// pushing changes.
//
// Parameters:
//   - socket: A pointer to a dagger.Socket that represents the Git SSH socket to be used.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithGitSSHSocket(socket *dagger.Socket) *TerragruntActionBuilder {
	b.gitSshSocket = socket
	return b
}

// Execute runs the Terragrunt action defined in the TerragruntActionBuilder.
// It prepares the execution environment by validating required parameters,
// setting up necessary configurations, and executing the Terragrunt command.
//
// Parameters:
//   - ctx: A context.Context that carries deadlines, cancellation signals,
//     and other request-scoped values across API boundaries and between
//     processes.
//
// Returns:
//   - A pointer to a dagger.Container that represents the result of the
//     executed action, or nil if an error occurs.
//   - An error that indicates whether the execution was successful or
//     if any issues were encountered during the process.
func (b *TerragruntActionBuilder) Execute(ctx context.Context) (*dagger.Container, error) {
	// Validate that the parent Terragrunt module is set
	if b.parent == nil {
		return nil, NewError("cannot execute action: parent Terragrunt module is nil")
	}

	// Validate that a command has been specified
	if b.command == "" {
		return nil, NewError("cannot execute action: command is empty")
	}

	// Validate that the binary is set
	if b.binary == "" {
		return nil, NewError("cannot execute action: binary is empty. Binary should be either 'terragrunt' or 'terraform'")
	}

	// Validate that the source directory is set
	if b.src == nil {
		return nil, NewError("cannot execute action: source directory is nil")
	}

	// Set the execution path for Terragrunt based on the unit environment,
	// layer, and name, or for Terraform modules based on the module name
	var actionWorkDir string
	if b.binary == "terragrunt" {
		actionWorkDir = getTerragruntExecutionPath(b.unitEnv, b.unitLayer, b.unitName)
	} else {
		actionWorkDir = getTerraformModulesExecutionPath(b.tfModule)
	}

	// Create a local copy of the parent Terragrunt instance to avoid
	// modifying shared state during execution
	localParent := &Terragrunt{
		Ctr: b.parent.Ctr,
		Src: b.parent.Src,
	}

	// Apply environment variables to the local parent copy if any are provided
	if len(b.envVars) > 0 {
		modDecorate, envVarErr := localParent.WithEnvVars(b.envVars)

		if envVarErr != nil {
			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
		}

		localParent = modDecorate
	}

	// Set AWS OIDC credentials if provided
	if b.awsAccessKeyID != nil && b.awsSecretKey != nil {
		localParent = localParent.WithAWSKeys(ctx, b.awsAccessKeyID, b.awsSecretKey, b.awsRegion)
	}

	// Set AWS OIDC credentials if provided.
	if b.awsRoleArn != "" && b.awsOidcToken != nil {
		localParent = localParent.WithAWSOIDC(b.awsRoleArn, b.awsOidcToken, "", b.awsRegion, b.awsRoleSessionName)
	}

	// Set any secrets that need to be passed to the execution context
	if len(b.secrets) > 0 {
		localParent = localParent.WithSecrets(ctx, b.secrets)
	}

	// Apply cache buster if specified
	if b.noCache {
		localParent = localParent.WithCacheBuster()
	}

	// Load environment variables from a .env file if specified
	if b.loadDotEnvFile {
		modDecorate, envVarErr := localParent.WithDotEnvFile(ctx, b.src)

		if envVarErr != nil {
			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
		}

		localParent = modDecorate
	}

	// Execute the Terragrunt command with the specified parameters
	execCtr, execErr := localParent.Exec(
		ctx,
		b.binary,
		b.command,
		b.args,
		b.autoApprove, // Use the autoApprove setting from the builder
		b.src,         // Use the source specified for this action
		actionWorkDir,
		b.envVars,
		b.secrets,
		b.tfToken,      // Use the Terraform token from the builder
		b.ghToken,      // Use the GitHub token from the builder
		b.glToken,      // Use the GitLab token from the builder
		b.gitSshSocket, // Use the Git SSH socket from the builder
		false,
		b.loadDotEnvFile, // loadDotEnvFile - assumes Exec handles this contextually
		"",
		false,
		false,
	)

	// Handle any errors that occur during execution
	if execErr != nil {
		return nil, WrapErrorf(execErr, "failed to execute the terragrunt action for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
	}

	// Return the resulting container from the execution
	return execCtr, nil
}

// cloneTerragrunt creates a deep copy of the Terragrunt struct to avoid concurrency issues
func cloneTerragrunt(original *Terragrunt) *Terragrunt {
	if original == nil {
		return nil
	}

	return &Terragrunt{
		Ctr: original.Ctr,
		Src: original.Src,
	}
}

// processActionResults collects results from concurrent actions executed in a separate goroutine.
// It aggregates any errors encountered during the execution and formats a success report.
// The function takes a channel of ActionResult, which contains the results of the actions,
// and returns a formatted string report of successful actions or an error if any occurred.
//
// Parameters:
//   - resultChan: A channel of ActionResult that receives results from concurrent actions.
//
// Returns:
//   - A string containing a summary of all successful actions and their outputs, or an empty string
//     if there were errors.
//   - An error that aggregates all encountered errors, or nil if no errors occurred.
func processActionAsyncResults(resultChan chan ActionResult) (string, error) {
	// collectors for errors and successful results
	var collectedActionErrors []error
	var successfulResults []ActionResult

	// Iterate over results received from the channel
	for result := range resultChan {
		if result.Err != nil {
			// Collect any errors encountered
			collectedActionErrors = append(collectedActionErrors, result.Err)
		} else {
			// Store successful results
			successfulResults = append(successfulResults, result)
		}
	}

	return formatResultsReport(collectedActionErrors, successfulResults)
}

// ProcessActionSyncResults collects results from a slice of synchronously executed actions.
// It aggregates any errors encountered during the execution and formats a success report
// by calling the internal formatResultsReport helper function.
// It takes a slice of ActionResult and returns a formatted string report or a joined error.
func ProcessActionSyncResults(results []ActionResult) (string, error) {
	// collectors
	var collectedActionErrors []error
	var successfulResults []ActionResult // Collect successful results in order

	// Separate errors and successes from the input slice
	for _, result := range results {
		if result.Err != nil {
			collectedActionErrors = append(collectedActionErrors, result.Err)
		} else {
			successfulResults = append(successfulResults, result)
		}
	}

	// Delegate processing and formatting to the helper function
	return formatResultsReport(collectedActionErrors, successfulResults)
}

// formatResultsReport takes collected errors and successful results, aggregates errors,
// and formats a success report. This is the core reusable logic.
func formatResultsReport(collectedActionErrors []error, successfulResults []ActionResult) (string, error) {
	// Handling errors first.
	if len(collectedActionErrors) > 0 {
		// Use JoinErrors from err.go (assuming it's in the same package or imported)
		return "", JoinErrors(collectedActionErrors...)
	}

	// Handling, and showing outputs
	var outputBuilder strings.Builder
	outputBuilder.WriteString("All actions passed successfully.\n\nOutput:\n") // Simplified success message
	outputBuilder.WriteString("=====================\n")

	// Display successful outputs in the order they were collected
	if len(successfulResults) == 0 {
		outputBuilder.WriteString("(No successful actions with output)\n")
	} else {
		for _, result := range successfulResults {
			// Use the existing String() method or format directly
			outputBuilder.WriteString(result.String()) // Assumes ActionResult has a useful String() method
			// Ensure a newline after each result's output if not already present by String()
			if !strings.HasSuffix(result.String(), "\n") {
				outputBuilder.WriteString("\n")
			}
			outputBuilder.WriteString("--------------------\n") // Separator
		}
	}

	return outputBuilder.String(), nil // Return combined stdout and nil error
}

// String returns a formatted string representation of the ActionResult.
// It includes the working directory, the command executed, and any output or error messages.
// If there is an error associated with the ActionResult, it will be included in the output.
// If there is no output, a default message indicating that is returned.
//
// The format of the returned string is as follows:
//   - If there is an error: "WorkDir [<WorkDir>]: Error - <ErrorMessage>"
//   - If there is no error and output is present:
//     "--- WorkDir: <ExecutionPath> ---\nCommand: <CommandName>\n<Output>"
//   - If there is no error and no output:
//     "--- WorkDir: <ExecutionPath> ---\nCommand: <CommandName>\n(No standard output)"
func (ar ActionResult) String() string {
	if ar.Err != nil {
		return fmt.Sprintf("WorkDir [%s]: Error - %v", ar.WorkDir, ar.Err)
	}

	output := "(No standard output)"

	if ar.Output != "" {
		output = ar.Output
	}

	// Format clearly indicating the unit and command (extracted from Unit key)
	parts := strings.Split(ar.WorkDir, ".")
	tgExecutionPath := ar.WorkDir
	commandName := ""

	if len(parts) == 2 {
		tgExecutionPath = parts[0]
		commandName = parts[1]
	}

	return fmt.Sprintf("--- WorkDir: %s ---\nCommand: %s\n%s", tgExecutionPath, commandName, output)
}
