package main

import (
	"context"
	"dagger/terragrunt/internal/dagger"
	"fmt"
	"sort"
	"strings"
	"sync"
)

// ActionResult represents the result of a Continuous Integration (CI) action.
// It contains information about the unit that was executed, the output of the action,
// and any error that may have occurred during execution.
type ActionResult struct {
	Unit   string // Unit indicates the specific unit of work that was executed.
	Output string // Output contains the result or output generated by the action.
	Err    error  // Err holds any error encountered during the execution of the action.
}

// TerragruntActionBuilder is a struct that helps configure and execute a single
// Terragrunt action. It encapsulates all necessary parameters and settings required
// to perform a Terragrunt command, such as "hclfmt", "validate", or "init".
type TerragruntActionBuilder struct {
	parent         *Terragrunt       // Reference to the main Terragrunt module that this action belongs to.
	command        string            // The specific Terragrunt command to be executed (e.g., "hclfmt", "validate", "init").
	args           []string          // A slice of additional arguments to be passed to the command.
	unitEnv        string            // The environment in which the Terragrunt unit operates (e.g., "global").
	unitLayer      string            // The layer of the Terragrunt unit (e.g., "dni").
	unitName       string            // The name of the Terragrunt unit (e.g., "dni_generator").
	src            *dagger.Directory // The source directory for this action, defaults to the parent module's source directory.
	awsAccessKeyID *dagger.Secret    // The AWS Access Key ID to be used for this action, if applicable.
	awsSecretKey   *dagger.Secret    // The AWS Secret Key to be used for this action, if applicable.
	awsRegion      string            // The AWS region to be used for this action.
	envVars        []string          // A slice of additional environment variables for this action.
	secrets        []*dagger.Secret  // A slice of additional secrets required for this action (name -> secret mapping).
	noCache        bool              // A flag indicating whether to apply a cache buster for this action.
	loadDotEnvFile bool              // A flag indicating whether to load a .env file for this action.
	autoApprove    bool              // A flag indicating whether to automatically approve Terraform commands like apply/destroy.
	tfToken        *dagger.Secret    // The Terraform registry token to be used for authentication, if applicable.
	ghToken        *dagger.Secret    // The GitHub token for accessing GitHub resources, if applicable.
	glToken        *dagger.Secret    // The GitLab token for accessing GitLab resources, if applicable.
	gitSshSocket   *dagger.Socket    // The Git SSH socket for supporting private Git repositories.
}

// NewAction creates and returns a new instance of the TerragruntActionBuilder struct,
// which is responsible for configuring and executing a specific Terragrunt command.
// The provided command parameter specifies the Terragrunt command to be executed,
// such as "hclfmt", "validate", or "init".
//
// This method initializes the builder with default values for the unit environment,
// layer, and name, as well as the AWS region and source directory. The default values
// are defined by constants such as defaultRefArchEnv, defaulttRefArchLayer, and
// defaulttRefArchUnit. The AWS region is set to "eu-central-1" by default.
//
// The source directory for the action defaults to the source directory of the parent
// Terragrunt instance, which can be overridden by using the WithSource method on the
// returned TerragruntActionBuilder instance.
//
// This method is typically called on a Terragrunt instance to prepare for executing
// a specific Terragrunt command, allowing for further configuration through method
// chaining on the returned builder instance.
//
// Parameters:
//   - command: A string representing the specific Terragrunt command to be executed.
//
// Returns:
//   - A pointer to a newly created TerragruntActionBuilder instance, initialized
//     with the specified command and default values for other parameters.
func (m *Terragrunt) NewAction(command string) *TerragruntActionBuilder {
	return &TerragruntActionBuilder{
		parent:    m,
		command:   command,
		unitEnv:   defaultRefArchEnv,
		unitLayer: defaulttRefArchLayer,
		unitName:  defaulttRefArchUnit,
		awsRegion: "eu-central-1",
		envVars:   []string{},
		secrets:   []*dagger.Secret{},
		src:       m.Src, // defaults to parent.Src
	}
}

// ForTgUnit configures the Terragrunt action with the specified unit environment, layer, and name.
// This method allows the user to set the context in which the Terragrunt command will be executed.
// If any of the parameters are empty strings, default values will be used instead.
//
// Parameters:
//   - env: A string representing the environment in which the command will run (e.g., "global").
//   - layer: A string representing the layer in which the command will run (e.g., "dni").
//   - unit: A string representing the name of the unit in which the command will run (e.g., "dni_generator").
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method chaining.
func (b *TerragruntActionBuilder) ForTgUnit(env, layer, unit string) *TerragruntActionBuilder {
	if env == "" {
		env = defaultRefArchEnv
	}

	if layer == "" {
		layer = defaulttRefArchLayer
	}

	if unit == "" {
		unit = defaulttRefArchUnit
	}

	b.unitEnv = env
	b.unitLayer = layer
	b.unitName = unit

	return b
}

// WithArgs appends additional command-line arguments to the Terragrunt command being built.
// This method allows users to specify any number of additional arguments that will be included
// when the command is executed. The arguments are added to the existing list of arguments,
// enabling flexible command construction.
//
// Parameters:
//   - args: A variadic parameter that accepts one or more strings representing the
//     additional arguments to be added to the command. These arguments will be appended
//     to the internal slice of arguments maintained by the TerragruntActionBuilder.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method chaining
//     to further configure the action.
func (b *TerragruntActionBuilder) WithArgs(args ...string) *TerragruntActionBuilder {
	b.args = append(b.args, args...)
	return b
}

// WithSource sets the source directory for the Terragrunt action being built.
// This method allows the user to specify a source directory that will be used
// during the execution of the Terragrunt command. If the provided source directory
// is not nil, it will be assigned to the action builder; otherwise, the existing
// source directory will remain unchanged.
//
// Parameters:
//   - src: A pointer to a dagger.Directory representing the source directory
//     to be used for the action. If src is nil, the source directory will not
//     be updated.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithSource(src *dagger.Directory) *TerragruntActionBuilder {
	if src != nil {
		b.src = src
	}

	return b
}

// WithAWS configures the AWS credentials for the Terragrunt action being built.
// This method allows users to specify the AWS access key ID, secret access key,
// and the AWS region that will be used during the execution of the Terragrunt command.
//
// Parameters:
//   - awsAccessKeyID: A pointer to a dagger.Secret representing the AWS access key ID
//     to be used for the action. If this parameter is nil, the access key ID will not
//     be set.
//   - awsSecretAccessKey: A pointer to a dagger.Secret representing the AWS secret
//     access key to be used for the action. If this parameter is nil, the secret access
//     key will not be set.
//   - awsRegion: A string representing the AWS region to be used for the action. If
//     the provided region is empty or not set, the default AWS region will be used.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for method
//     chaining to further configure the action.
func (b *TerragruntActionBuilder) WithAWS(awsAccessKeyID, awsSecretAccessKey *dagger.Secret, awsRegion string) *TerragruntActionBuilder {
	awsRegion = getDefaultAWSRegionIfNotSet(awsRegion)

	b.awsAccessKeyID = awsAccessKeyID
	b.awsSecretKey = awsSecretAccessKey
	b.awsRegion = awsRegion

	return b
}

// WithEnv adds an environment variable to the Terragrunt action being built.
// This method allows users to specify a key-value pair that will be set as an
// environment variable during the execution of the action. If either the key or
// the value is an empty string, the environment variable will not be added.
//
// Parameters:
//   - key: A string representing the name of the environment variable to be set.
//   - value: A string representing the value of the environment variable to be set.
//
// Returns:
//   - A pointer to the updated TerragruntActionBuilder instance, allowing for
//     method chaining to further configure the action.
func (b *TerragruntActionBuilder) WithEnv(key, value string) *TerragruntActionBuilder {
	if key != "" && value != "" {
		b.envVars = append(b.envVars, fmt.Sprintf("%s=%s", key, value))
	}

	return b
}

// WithSecret adds a secret to the action.
//
// Parameters:
//   - key: The key of the secret.
//   - secret: The secret to add to the action.
func (b *TerragruntActionBuilder) WithSecret(ctx context.Context, name string, secret *dagger.Secret) *TerragruntActionBuilder {
	if secret == nil {
		return b
	}

	secretPlainTxtValue, _ := secret.Plaintext(ctx)
	newSecret := dag.SetSecret(name, secretPlainTxtValue)
	b.secrets = append(b.secrets, newSecret)

	return b
}

// WithNoCache sets the cache buster for the action.
func (b *TerragruntActionBuilder) WithNoCache() *TerragruntActionBuilder {
	b.noCache = true
	return b
}

// WithLoadDotEnvFile loads the .env file for the action.
func (b *TerragruntActionBuilder) WithLoadDotEnvFile() *TerragruntActionBuilder {
	b.loadDotEnvFile = true
	return b
}

// WithAutoApprove sets the auto approve flag for apply or destroy commands.
func (b *TerragruntActionBuilder) WithAutoApprove() *TerragruntActionBuilder {
	b.autoApprove = true
	return b
}

// WithTerraformToken sets the Terraform registry token for this action.
func (b *TerragruntActionBuilder) WithTerraformToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.tfToken = token
	return b
}

// WithGitHubToken sets the GitHub token for this action.
func (b *TerragruntActionBuilder) WithGitHubToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.ghToken = token
	return b
}

// WithGitLabToken sets the GitLab token for this action.
func (b *TerragruntActionBuilder) WithGitLabToken(token *dagger.Secret) *TerragruntActionBuilder {
	b.glToken = token
	return b
}

// WithGitSSHSocket sets the Git SSH socket for this action.
func (b *TerragruntActionBuilder) WithGitSSHSocket(socket *dagger.Socket) *TerragruntActionBuilder {
	b.gitSshSocket = socket
	return b
}

func (b *TerragruntActionBuilder) Execute(ctx context.Context) (*dagger.Container, error) {
	if b.parent == nil {
		return nil, NewError("cannot execute action: parent Terragrunt module is nil")
	}
	if b.command == "" {
		return nil, NewError("cannot execute action: command is empty")
	}
	if b.src == nil {
		return nil, NewError("cannot execute action: source directory is nil")
	}

	// Set terragrunt execution path
	tgUnitPath := getTerragruntUnitPath(b.unitEnv, b.unitLayer, b.unitName)

	// Create a local copy of the parent to avoid modifying shared state
	localParent := &Terragrunt{
		Ctr: b.parent.Ctr,
		Src: b.parent.Src,
	}

	// Apply all configurations to the local parent copy
	if len(b.envVars) > 0 {
		modDecorate, envVarErr := localParent.WithEnvVars(b.envVars)

		if envVarErr != nil {
			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
		}

		localParent = modDecorate
	}

	// Set AWS credentials
	if b.awsAccessKeyID != nil && b.awsSecretKey != nil {
		localParent = localParent.WithAWSCredentials(ctx, b.awsAccessKeyID, b.awsSecretKey, b.awsRegion)
	}

	// Set secrets
	if len(b.secrets) > 0 {
		localParent = localParent.WithSecrets(ctx, b.secrets)
	}

	// Set cache buster
	if b.noCache {
		localParent = localParent.WithCacheBuster()
	}

	// Set loadDotEnvFile
	if b.loadDotEnvFile {
		modDecorate, envVarErr := localParent.WithDotEnvFile(ctx, b.src)

		if envVarErr != nil {
			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
		}

		localParent = modDecorate
	}

	execCtr, execErr := localParent.Exec(
		ctx,
		"terragrunt",
		b.command,
		b.args,
		b.autoApprove, // Use the autoApprove setting from the builder
		b.src,         // Use the source specified for this action
		tgUnitPath,
		b.envVars,
		b.secrets,
		b.tfToken,      // Use the Terraform token from the builder
		b.ghToken,      // Use the GitHub token from the builder
		b.glToken,      // Use the GitLab token from the builder
		b.gitSshSocket, // Use the Git SSH socket from the builder
		false,
		b.loadDotEnvFile, // loadDotEnvFile - assumes Exec handles this contextually
	)

	if execErr != nil {
		return nil, WrapErrorf(execErr, "failed to execute the terragrunt action for the following environment: %s, layer: %s, unit: %s", b.unitEnv, b.unitLayer, b.unitName)
	}

	return execCtr, nil
}

// String returns a string representation of the ActionResult.
func (ar ActionResult) String() string {
	if ar.Err != nil {
		return fmt.Sprintf("Unit [%s]: Error - %v", ar.Unit, ar.Err)
	}
	if ar.Output != "" {
		return fmt.Sprintf("Unit [%s]:\n%s", ar.Unit, ar.Output)
	}
	return fmt.Sprintf("Unit [%s]: OK (No specific output)", ar.Unit) // Or just OK
}

// cloneTerragrunt creates a deep copy of the Terragrunt struct to avoid concurrency issues
func cloneTerragrunt(original *Terragrunt) *Terragrunt {
	if original == nil {
		return nil
	}
	return &Terragrunt{
		Ctr: original.Ctr,
		Src: original.Src,
	}
}

func (m *Terragrunt) JobTerragruntUnitStaticCheck(
	// ctx is the context for the Dagger container.
	// +optional
	ctx context.Context,
	// awsAccessKeyID is the AWS access key ID to use for the command.
	awsAccessKeyID *dagger.Secret,
	// awsSecretAccessKey is the AWS secret access key to use for the command.
	awsSecretAccessKey *dagger.Secret,
	// noCache set the cache buster
	// +optional
	noCache bool,
	// tgArgs are the arbitrary arguments to pass to the terrawgrunt command
	// +optional
	tgArgs []string,
	// loadDotEnvFile is a boolean indicating whether to load .env file
	// +optional
	loadDotEnvFile bool,
) (string, error) {
	units := []string{
		"dni_generator",
		"lastname_generator",
		"name_generator",
		"age_generator",
	}

	// actions to run on this job
	actions := []struct {
		Command string
		Args    []string
	}{
		{
			Command: "hclfmt",
			Args:    []string{"--check", "--diff"},
		},
		{
			Command: "terragrunt-info",
			Args:    []string{},
		},
		{
			Command: "validate-inputs",
			Args:    []string{},
		},
	}

	var wg sync.WaitGroup
	// Buffered channel, so we can collect the results safely.
	resultChan := make(chan ActionResult, len(units)*len(actions))

	// Run each unit check concurrently
	for _, unit := range units {
		for _, action := range actions {
			currentUnit := unit
			currentAction := action

			wg.Add(1)

			go func() {
				defer wg.Done()
				var finalErr error
				var finalOutput string

				// Create a clone of the Terragrunt struct to avoid concurrency issues
				terragruntClone := cloneTerragrunt(m)

				// Builder
				actionBuilder := terragruntClone.NewAction(currentAction.Command)
				actionBuilder.ForTgUnit(defaultRefArchEnv, defaulttRefArchLayer, currentUnit)
				actionBuilder.WithSource(terragruntClone.Src)
				actionBuilder.WithAWS(awsAccessKeyID, awsSecretAccessKey, "eu-central-1")
				actionBuilder.WithNoCache()
				actionBuilder.WithArgs(currentAction.Args...)
				actionBuilder.WithLoadDotEnvFile()

				// Execute
				compiledCtr, buildErr := actionBuilder.Execute(ctx)
				if buildErr != nil {
					finalErr = WrapErrorf(buildErr, "failed to execute the terragrunt action for the following environment: %s, layer: %s, unit: %s", currentUnit, defaulttRefArchLayer, currentUnit)
				} else {
					// get the stdout of the action
					stdOut, stdOutErr := compiledCtr.Stdout(ctx)
					if stdOutErr != nil {
						finalErr = WrapErrorf(stdOutErr, "failed to get the stdout of the terragrunt action for the following environment: %s, layer: %s, unit: %s", currentUnit, defaulttRefArchLayer, currentUnit)
					} else {
						finalOutput = stdOut
					}
				}

				// Collect results
				resultChan <- ActionResult{
					Unit:   fmt.Sprintf("%s.%s", currentUnit, currentAction.Command),
					Output: finalOutput,
					Err:    finalErr,
				}
			}()
		}
	}

	// Wait for all goroutines to complete
	wg.Wait()
	close(resultChan)

	// collectors
	var collectedActionErrors []error
	// I'm opinionated, here the key defined is "unit.command"
	successfulOutputs := make(map[string]string)

	for result := range resultChan {
		if result.Err != nil {
			collectedActionErrors = append(collectedActionErrors, result.Err)
		} else {
			successfulOutputs[result.Unit] = result.Output
		}
	}

	// Handling, and showing errors.
	if len(collectedActionErrors) > 0 {
		return "", JoinErrors(collectedActionErrors...)
	}

	// Handling, and showing outputs
	var outputBuilder strings.Builder
	outputBuilder.WriteString("All static checks passed successfully.\n\nOutput per unit:\n")
	outputBuilder.WriteString("=====================\n")

	// Group outputs by unit
	unitOutputs := make(map[string]map[string]string)
	for key, output := range successfulOutputs {
		parts := strings.Split(key, ".")
		if len(parts) == 2 {
			unit, command := parts[0], parts[1]
			if _, ok := unitOutputs[unit]; !ok {
				unitOutputs[unit] = make(map[string]string)
			}
			unitOutputs[unit][command] = output
		}
	}

	// Sort units for consistent output order
	sortedUnits := make([]string, 0, len(unitOutputs))
	for unit := range unitOutputs {
		sortedUnits = append(sortedUnits, unit)
	}
	sort.Strings(sortedUnits)

	// Display outputs by unit and command
	for _, unit := range sortedUnits {
		outputBuilder.WriteString(fmt.Sprintf("--- Unit: %s ---\n", unit))

		// Sort commands for consistent output order
		commands := make([]string, 0, len(unitOutputs[unit]))
		for cmd := range unitOutputs[unit] {
			commands = append(commands, cmd)
		}
		sort.Strings(commands)

		for _, cmd := range commands {
			outputBuilder.WriteString(fmt.Sprintf("Command: %s\n", cmd))
			stdout := unitOutputs[unit][cmd]
			if stdout == "" {
				outputBuilder.WriteString("(No standard output)\n")
			} else {
				outputBuilder.WriteString(stdout)
				// Ensure a newline after each command's output if not already present
				if !strings.HasSuffix(stdout, "\n") {
					outputBuilder.WriteString("\n")
				}
			}
			outputBuilder.WriteString("\n")
		}
		outputBuilder.WriteString("--------------------\n")
	}

	return outputBuilder.String(), nil // Return combined stdout and nil error
}

// func (m *Terragrunt) ActionTerragruntHclValidate(
// 	// ctx is the context for the Dagger container.
// 	// +optional
// 	ctx context.Context,
// 	// src is the source directory for the Dagger container.
// 	// +optional
// 	// +defaultPath="/"
// 	// +ignore=["*", "!**/*.hcl", "!**/*.tfvars", "!**/.git/**", "!**/*.tfvars.json", "!**/*.tf", "!*.env", "!*.envrc", "!*.envrc"]
// 	src *dagger.Directory,
// 	// env is the environment to run the command in, following the pattern infra/terraform/[env]/[layer]/[unit]
// 	// +optional
// 	env string,
// 	// layer is the terragrunt layer to run the command in (pattern infra/terraform/[env]/[layer]/[unit])
// 	// +optional
// 	layer string,
// 	// unit is the terragrunt unit to run the command in (pattern infra/terraform/[env]/[layer]/[unit])
// 	// +optional
// 	unit string,
// 	// awsAccessKeyID is the AWS access key ID to use for the command.
// 	awsAccessKeyID *dagger.Secret,
// 	// awsSecretAccessKey is the AWS secret access key to use for the command.
// 	awsSecretAccessKey *dagger.Secret,
// 	// awsRegion is the AWS region to use for the command.
// 	// +optional
// 	awsRegion string,
// 	// envVars is a slice of strings including all environment variables to pass to the command.
// 	// +optional
// 	envVars []string,
// 	// noCache set the cache buster
// 	// +optional
// 	noCache bool,
// 	// tgArgs are the arbitrary arguments to pass to the terrawgrunt command
// 	// +optional
// 	tgArgs []string,
// 	// loadDotEnvFile is a boolean indicating whether to load .env file
// 	// +optional
// 	loadDotEnvFile bool,
// ) (*dagger.Container, error) {
// 	if env == "" {
// 		env = defaultRefArchEnv
// 	}

// 	if layer == "" {
// 		layer = defaulttRefArchLayer
// 	}

// 	if unit == "" {
// 		unit = defaulttRefArchUnit
// 	}

// 	if awsAccessKeyID != nil && awsSecretAccessKey != nil {
// 		m = m.WithAWSCredentials(ctx, awsAccessKeyID, awsSecretAccessKey, awsRegion)
// 	}

// 	if len(envVars) > 0 {
// 		modDecorate, envVarErr := m.WithEnvVars(envVars)

// 		if envVarErr != nil {
// 			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 		}

// 		m = modDecorate
// 	}

// 	if noCache {
// 		m = m.WithCacheBuster()
// 	}

// 	tgPath := getTerragruntUnitPath(env, layer, unit)

// 	// Run 'terragrunt hclvalidate'
// 	tgHclValidateCtr, tgHclValidateCtrErr := m.Exec(
// 		ctx,
// 		"terragrunt",                   // binary
// 		"hclvalidate",                  // command
// 		[]string{"--show-config-path"}, // args
// 		false,                          // autoApprove
// 		src,                            // src (we are operating within the base src context m.Src)
// 		tgPath,                         // tgUnitPath
// 		nil,                            // envVars (already set on m.Ctr by parseDotEnvFiles)
// 		nil,                            // secrets (already set on m.Ctr by parseDotEnvFiles if applicable)
// 		nil,                            // tfToken
// 		nil,                            // ghToken
// 		nil,                            // glToken
// 		nil,                            // gitSshSocket
// 		true,                           // printPaths
// 		loadDotEnvFile,                 // loadEnvFiles
// 	)

// 	if tgHclValidateCtrErr != nil {
// 		return nil, WrapErrorf(tgHclValidateCtrErr, "failed to run the terragrunt action for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 	}

// 	return tgHclValidateCtr, nil
// }

// func (m *Terragrunt) ActionTerragruntHCLFmt(
// 	// ctx is the context for the Dagger container.
// 	// +optional
// 	ctx context.Context,
// 	// src is the source directory for the Dagger container.
// 	// +optional
// 	// +defaultPath="/"
// 	// +ignore=["*", "!**/*.hcl", "!**/*.tfvars", "!**/.git/**", "!**/*.tfvars.json", "!**/*.tf", "!*.env", "!*.envrc", "!*.envrc"]
// 	src *dagger.Directory,
// 	// env is the environment to run the command in, following the pattern infra/terraform/[env]/[layer]/[unit]
// 	// +optional
// 	env string,
// 	// layer is the terragrunt layer to run the command in (pattern infra/terraform/[env]/[layer]/[unit])
// 	// +optional
// 	layer string,
// 	// unit is the terragrunt unit to run the command in (pattern infra/terraform/[env]/[layer]/[unit])
// 	// +optional
// 	unit string,
// 	// awsAccessKeyID is the AWS access key ID to use for the command.
// 	awsAccessKeyID *dagger.Secret,
// 	// awsSecretAccessKey is the AWS secret access key to use for the command.
// 	awsSecretAccessKey *dagger.Secret,
// 	// awsRegion is the AWS region to use for the command.
// 	// +optional
// 	awsRegion string,
// 	// envVars is a slice of strings including all environment variables to pass to the command.
// 	// +optional
// 	envVars []string,
// 	// noCache set the cache buster
// 	// +optional
// 	noCache bool,
// 	// tgArgs are the arbitrary arguments to pass to the terrawgrunt command
// 	// +optional
// 	tgArgs []string,
// 	// loadDotEnvFile is a boolean indicating whether to load .env file
// 	// +optional
// 	loadDotEnvFile bool,
// ) (*dagger.Container, error) {
// 	if env == "" {
// 		env = defaultRefArchEnv
// 	}

// 	if layer == "" {
// 		layer = defaulttRefArchLayer
// 	}

// 	if unit == "" {
// 		unit = defaulttRefArchUnit
// 	}

// 	if awsAccessKeyID != nil && awsSecretAccessKey != nil {
// 		m = m.WithAWSCredentials(ctx, awsAccessKeyID, awsSecretAccessKey, awsRegion)
// 	}

// 	if len(envVars) > 0 {
// 		modDecorate, envVarErr := m.WithEnvVars(envVars)

// 		if envVarErr != nil {
// 			return nil, WrapErrorf(envVarErr, "failed to set environment variables for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 		}

// 		m = modDecorate
// 	}

// 	if noCache {
// 		m = m.WithCacheBuster()
// 	}

// 	tgPath := getTerragruntUnitPath(env, layer, unit)

// 	// Run HCLfmt
// 	tgHclFmtCtr, tgHclFmtCtrErr := m.Exec(
// 		ctx,
// 		"terragrunt",                           // binary
// 		"hclfmt",                               // command
// 		[]string{"--check", "--all", "--diff"}, // args
// 		false,                                  // autoApprove
// 		src,                                    // src (we are operating within the base src context m.Src)
// 		tgPath,                                 // tgUnitPath
// 		nil,                                    // envVars (already set on m.Ctr by parseDotEnvFiles)
// 		nil,                                    // secrets (already set on m.Ctr by parseDotEnvFiles if applicable)
// 		nil,                                    // tfToken
// 		nil,                                    // ghToken
// 		nil,                                    // glToken
// 		nil,                                    // gitSshSocket
// 		true,                                   // printPaths
// 		loadDotEnvFile,                         // loadEnvFiles
// 	)

// 	if tgHclFmtCtrErr != nil {
// 		return nil, WrapErrorf(tgHclFmtCtrErr, "failed to run the terragrunt action for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 	}

// 	return tgHclFmtCtr, nil

// 	// _, tgHclOutErr := tgHclFmtCtr.Stdout(ctx)
// 	// if tgHclOutErr != nil {
// 	// 	return "", WrapErrorf(tgHclOutErr, "failed to get the stdout of the terragrunt action for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 	// }

// 	// // Run 'terragrunt hclvalidate'
// 	// tgHclValidateCtr, tgHclValidateCtrErr := m.Exec(
// 	// 	ctx,
// 	// 	"terragrunt",                   // binary
// 	// 	"hclvalidate",                  // command
// 	// 	[]string{"--show-config-path"}, // args
// 	// 	false,                          // autoApprove
// 	// 	src,                            // src (we are operating within the base src context m.Src)
// 	// 	tgPath,                         // tgUnitPath
// 	// 	nil,                            // envVars (already set on m.Ctr by parseDotEnvFiles)
// 	// 	nil,                            // secrets (already set on m.Ctr by parseDotEnvFiles if applicable)
// 	// 	nil,                            // tfToken
// 	// 	nil,                            // ghToken
// 	// 	nil,                            // glToken
// 	// 	nil,                            // gitSshSocket
// 	// 	true,                           // printPaths
// 	// 	loadDotEnvFile,                 // loadEnvFiles
// 	// )

// 	// if tgHclValidateCtrErr != nil {
// 	// 	return "", WrapErrorf(tgHclValidateCtrErr, "failed to run the terragrunt action for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 	// }

// 	// _, tgHclValidateOutErr := tgHclValidateCtr.Stdout(ctx)
// 	// if tgHclValidateOutErr != nil {
// 	// 	return "", WrapErrorf(tgHclValidateOutErr, "failed to get the stdout of the terragrunt action for the following environment: %s, layer: %s, unit: %s", env, layer, unit)
// 	// }

// 	// return "", nil
// }
